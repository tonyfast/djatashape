(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.coffeetable = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var DjataShape, PEG, error;

PEG = require("pegjs");

DjataShape = (function() {
  function DjataShape() {
    this.parse = PEG.buildParser("/** A PegJS grammar for Python DataShape **/\n\n{\n  function toObject( array ){\n    /** Convert an array of {key,value} objects to an objecy **/\n    var tmp = {};\n    array.forEach( function(entry){\n        tmp[entry.key] = entry.value;\n    });\n    if ( tmp === {} ){ return null; }\n    return tmp;\n  };\n}\n\n/** First Parsing Expression **/\ndatashape = output:(shapes / structure / type ) _ { return output; }\n\n/** Array Shapes trail with a type **/\nshapes = _ shape:(shape)+ _ type:datashape {\n  return {\n    shape: shape,\n    type: type\n  };\n}\n\n/** The shape is an integer or ``var`` separated by an asterisk **/\nshape = shape:( integer / \"var\" ) _ '*' _  { return shape; }\n\n/** Object DataShape defintion **/\nstructure =  '{' _ entries:structure_entries? entry:(structure_entry) '}' {\n  entries = entries ? entries : [];\n  entries.push(entry = entry ? entry : void(0));\n  return toObject( entries );\n}\n\n/** key/value pairs separated with a colon **/\nstructure_entry = key:string _ ':' _ value:datashape { return { key: key, value: value,}; }\nstructure_entries = entries:( entry:structure_entry _ ',' _ { return entry; })+ { return entries; }\n\n/** DataShape types **/\ntype = inferred:'?'?  type:types params:compound? {\n  if ( params || inferred ){\n      params = params ? params : {}\n      inferred ? ( params['inferred'] = true ) : void(0);\n      return {type: type, params: params }\n  } else {\n      return {type: type}\n  }\n}\n\ntypes = (t:'int' b:(\"8\"/\"16\"/\"32\"/\"64\"/\"128\")? { return t+(b==null?'32':b) }) /\n    (t:'unit' b:(\"8\"/\"16\"/\"32\"/\"64\"/\"128\")? { return t+(b==null?'32':b) }) /\n    (t:'float' b:(\"8\"/\"16\"/\"32\"/\"64\"/\"128\")? { return t+(b==null?'32':b) }) /\n    (t:'decimal' b:(\"32\"/\"64\"/\"128\")? { return t+(b==null?'32':b) }) /\n    t:('char' / 'json' / 'void' / 'pointer' / 'complex' / 'string' / 'bytes' / 'datetime' / 'categorical') { return t;  }\n\ncompound = '[' arg:(simple_type / args:(compound_type)+ { return args; } ) _ ']' { return arg; }\n\nsimple_type = value:types { return { key: 'type', value: value } }\n\ncompound_type  =  _ entries:compound_entries? entry:(compound_entry) {\n  entries = entries ? entries : [];\n  entries.push(entry = entry ? entry : void(0));\n  return toObject( entries );\n}\n\ncompound_entries = entries:(entry:compound_entry  _ ',' _ { return entry; } )+ { return entries };\ncompound_entry = key:string _ '=' _ value:(literal_string/types/list) { return { key: key, value: value,};  } /\n  value:types { return {key: 'type', value: value}; }\n\nlist = '['_ entries:(_ v:literal_string _ ',' { return v;})* _ entry:literal_string _ ']' {\n  entries = entries ? entries : [];\n  entries.push(entry = entry ? entry : void(0));\n  return entries;\n}\n\n\nliteral_string = ( '\"' s:string '\"' {return s;} / \"'\" s:string \"'\" {return s;})\nstring = chars:([a-zA-Z0-9_ ])+ { return chars.join('') }\ninteger = value:[0-9]+ { return parseFloat(value.join(\"\"), 10); }\n\n_  = [\\ \\t\\r\\n]*\n").parse;
  }

  return DjataShape;

})();

try {
  window.DjataShape = DjataShape;
} catch (error) {
  console.log("whatever");
}

module.exports = DjataShape;


},{"pegjs":"pegjs"}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZGphdGFzaGFwZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxJQUFBOztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsT0FBUjs7QUFFQTtFQUNTLG9CQUFBO0lBQ1gsSUFBQyxDQUFBLEtBQUQsR0FBUyxHQUFHLENBQUMsV0FBSixDQUFnQiwwOUZBQWhCLENBcUZULENBQUM7RUF0RlU7Ozs7OztBQXdGZjtFQUNFLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLFdBRHRCO0NBQUEsYUFBQTtFQUdFLE9BQU8sQ0FBQyxHQUFSLENBQVksVUFBWixFQUhGOzs7QUFLQSxNQUFNLENBQUMsT0FBUCxHQUFpQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJQRUcgPSByZXF1aXJlIFwicGVnanNcIlxuXG5jbGFzcyBEamF0YVNoYXBlXG4gIGNvbnN0cnVjdG9yOiAoKS0+XG4gICAgQHBhcnNlID0gUEVHLmJ1aWxkUGFyc2VyIFwiXCJcIlxuICAgIC8qKiBBIFBlZ0pTIGdyYW1tYXIgZm9yIFB5dGhvbiBEYXRhU2hhcGUgKiovXG5cbiAgICB7XG4gICAgICBmdW5jdGlvbiB0b09iamVjdCggYXJyYXkgKXtcbiAgICAgICAgLyoqIENvbnZlcnQgYW4gYXJyYXkgb2Yge2tleSx2YWx1ZX0gb2JqZWN0cyB0byBhbiBvYmplY3kgKiovXG4gICAgICAgIHZhciB0bXAgPSB7fTtcbiAgICAgICAgYXJyYXkuZm9yRWFjaCggZnVuY3Rpb24oZW50cnkpe1xuICAgICAgICAgICAgdG1wW2VudHJ5LmtleV0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICggdG1wID09PSB7fSApeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogRmlyc3QgUGFyc2luZyBFeHByZXNzaW9uICoqL1xuICAgIGRhdGFzaGFwZSA9IG91dHB1dDooc2hhcGVzIC8gc3RydWN0dXJlIC8gdHlwZSApIF8geyByZXR1cm4gb3V0cHV0OyB9XG5cbiAgICAvKiogQXJyYXkgU2hhcGVzIHRyYWlsIHdpdGggYSB0eXBlICoqL1xuICAgIHNoYXBlcyA9IF8gc2hhcGU6KHNoYXBlKSsgXyB0eXBlOmRhdGFzaGFwZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzaGFwZSBpcyBhbiBpbnRlZ2VyIG9yIGBgdmFyYGAgc2VwYXJhdGVkIGJ5IGFuIGFzdGVyaXNrICoqL1xuICAgIHNoYXBlID0gc2hhcGU6KCBpbnRlZ2VyIC8gXCJ2YXJcIiApIF8gJyonIF8gIHsgcmV0dXJuIHNoYXBlOyB9XG5cbiAgICAvKiogT2JqZWN0IERhdGFTaGFwZSBkZWZpbnRpb24gKiovXG4gICAgc3RydWN0dXJlID0gICd7JyBfIGVudHJpZXM6c3RydWN0dXJlX2VudHJpZXM/IGVudHJ5OihzdHJ1Y3R1cmVfZW50cnkpICd9JyB7XG4gICAgICBlbnRyaWVzID0gZW50cmllcyA/IGVudHJpZXMgOiBbXTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSA9IGVudHJ5ID8gZW50cnkgOiB2b2lkKDApKTtcbiAgICAgIHJldHVybiB0b09iamVjdCggZW50cmllcyApO1xuICAgIH1cblxuICAgIC8qKiBrZXkvdmFsdWUgcGFpcnMgc2VwYXJhdGVkIHdpdGggYSBjb2xvbiAqKi9cbiAgICBzdHJ1Y3R1cmVfZW50cnkgPSBrZXk6c3RyaW5nIF8gJzonIF8gdmFsdWU6ZGF0YXNoYXBlIHsgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSx9OyB9XG4gICAgc3RydWN0dXJlX2VudHJpZXMgPSBlbnRyaWVzOiggZW50cnk6c3RydWN0dXJlX2VudHJ5IF8gJywnIF8geyByZXR1cm4gZW50cnk7IH0pKyB7IHJldHVybiBlbnRyaWVzOyB9XG5cbiAgICAvKiogRGF0YVNoYXBlIHR5cGVzICoqL1xuICAgIHR5cGUgPSBpbmZlcnJlZDonPyc/ICB0eXBlOnR5cGVzIHBhcmFtczpjb21wb3VuZD8ge1xuICAgICAgaWYgKCBwYXJhbXMgfHwgaW5mZXJyZWQgKXtcbiAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgPyBwYXJhbXMgOiB7fVxuICAgICAgICAgIGluZmVycmVkID8gKCBwYXJhbXNbJ2luZmVycmVkJ10gPSB0cnVlICkgOiB2b2lkKDApO1xuICAgICAgICAgIHJldHVybiB7dHlwZTogdHlwZSwgcGFyYW1zOiBwYXJhbXMgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IHR5cGV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHlwZXMgPSAodDonaW50JyBiOihcIjhcIi9cIjE2XCIvXCIzMlwiL1wiNjRcIi9cIjEyOFwiKT8geyByZXR1cm4gdCsoYj09bnVsbD8nMzInOmIpIH0pIC9cbiAgICAgICAgKHQ6J3VuaXQnIGI6KFwiOFwiL1wiMTZcIi9cIjMyXCIvXCI2NFwiL1wiMTI4XCIpPyB7IHJldHVybiB0KyhiPT1udWxsPyczMic6YikgfSkgL1xuICAgICAgICAodDonZmxvYXQnIGI6KFwiOFwiL1wiMTZcIi9cIjMyXCIvXCI2NFwiL1wiMTI4XCIpPyB7IHJldHVybiB0KyhiPT1udWxsPyczMic6YikgfSkgL1xuICAgICAgICAodDonZGVjaW1hbCcgYjooXCIzMlwiL1wiNjRcIi9cIjEyOFwiKT8geyByZXR1cm4gdCsoYj09bnVsbD8nMzInOmIpIH0pIC9cbiAgICAgICAgdDooJ2NoYXInIC8gJ2pzb24nIC8gJ3ZvaWQnIC8gJ3BvaW50ZXInIC8gJ2NvbXBsZXgnIC8gJ3N0cmluZycgLyAnYnl0ZXMnIC8gJ2RhdGV0aW1lJyAvICdjYXRlZ29yaWNhbCcpIHsgcmV0dXJuIHQ7ICB9XG5cbiAgICBjb21wb3VuZCA9ICdbJyBhcmc6KHNpbXBsZV90eXBlIC8gYXJnczooY29tcG91bmRfdHlwZSkrIHsgcmV0dXJuIGFyZ3M7IH0gKSBfICddJyB7IHJldHVybiBhcmc7IH1cblxuICAgIHNpbXBsZV90eXBlID0gdmFsdWU6dHlwZXMgeyByZXR1cm4geyBrZXk6ICd0eXBlJywgdmFsdWU6IHZhbHVlIH0gfVxuXG4gICAgY29tcG91bmRfdHlwZSAgPSAgXyBlbnRyaWVzOmNvbXBvdW5kX2VudHJpZXM/IGVudHJ5Oihjb21wb3VuZF9lbnRyeSkge1xuICAgICAgZW50cmllcyA9IGVudHJpZXMgPyBlbnRyaWVzIDogW107XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkgPSBlbnRyeSA/IGVudHJ5IDogdm9pZCgwKSk7XG4gICAgICByZXR1cm4gdG9PYmplY3QoIGVudHJpZXMgKTtcbiAgICB9XG5cbiAgICBjb21wb3VuZF9lbnRyaWVzID0gZW50cmllczooZW50cnk6Y29tcG91bmRfZW50cnkgIF8gJywnIF8geyByZXR1cm4gZW50cnk7IH0gKSsgeyByZXR1cm4gZW50cmllcyB9O1xuICAgIGNvbXBvdW5kX2VudHJ5ID0ga2V5OnN0cmluZyBfICc9JyBfIHZhbHVlOihsaXRlcmFsX3N0cmluZy90eXBlcy9saXN0KSB7IHJldHVybiB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsfTsgIH0gL1xuICAgICAgdmFsdWU6dHlwZXMgeyByZXR1cm4ge2tleTogJ3R5cGUnLCB2YWx1ZTogdmFsdWV9OyB9XG5cbiAgICBsaXN0ID0gJ1snXyBlbnRyaWVzOihfIHY6bGl0ZXJhbF9zdHJpbmcgXyAnLCcgeyByZXR1cm4gdjt9KSogXyBlbnRyeTpsaXRlcmFsX3N0cmluZyBfICddJyB7XG4gICAgICBlbnRyaWVzID0gZW50cmllcyA/IGVudHJpZXMgOiBbXTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSA9IGVudHJ5ID8gZW50cnkgOiB2b2lkKDApKTtcbiAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgIH1cblxuXG4gICAgbGl0ZXJhbF9zdHJpbmcgPSAoICdcIicgczpzdHJpbmcgJ1wiJyB7cmV0dXJuIHM7fSAvIFwiJ1wiIHM6c3RyaW5nIFwiJ1wiIHtyZXR1cm4gczt9KVxuICAgIHN0cmluZyA9IGNoYXJzOihbYS16QS1aMC05XyBdKSsgeyByZXR1cm4gY2hhcnMuam9pbignJykgfVxuICAgIGludGVnZXIgPSB2YWx1ZTpbMC05XSsgeyByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5qb2luKFwiXCIpLCAxMCk7IH1cblxuICAgIF8gID0gW1xcXFwgXFxcXHRcXFxcclxcXFxuXSpcblxuICAgIFwiXCJcIlxuICAgIC5wYXJzZVxuXG50cnlcbiAgd2luZG93LkRqYXRhU2hhcGUgPSBEamF0YVNoYXBlXG5jYXRjaFxuICBjb25zb2xlLmxvZyBcIndoYXRldmVyXCJcblxubW9kdWxlLmV4cG9ydHMgPSBEamF0YVNoYXBlXG4iXX0=
